/*
 * Copyright 2019 Joyent, Inc.
 */

use crate::error::{Error, InternalError, InternalErrorCode};
use crate::picker as mod_picker;
use crate::picker::{StorageNode};
use crate::config::Config;
use crate::util;
use crossbeam_channel as crossbeam;
use libmanta::moray::{MantaObject, MantaObjectShark};
use std::error::Error as _Error;
use std::io::ErrorKind;
use std::sync::Arc;
use std::thread;
use uuid::Uuid;

#[derive(Debug, Clone)]
pub struct Job {
    id: Uuid,
    action: JobAction,
    state: JobState,
    config: Config,
}

#[derive(Debug, Clone)]
pub enum JobState {
    Init,
    Setup,
    Running,
    Stopped,
    Complete,
    Failed,
}

#[derive(Debug, Clone)]
pub enum JobAction {
    Evacuate(EvacuateJob),
    None,
}

#[derive(Debug, Clone)]
enum EvacuateObjectStatus {
    Unprocessed, // Default state
    Processing, // Object has been included in an assignment and that
                // assignment has been submitted to a remora agent.
    Skipped, // Could not find a shark to put this object in. TODO: Why?
    Failed, // Failed to Evacuate Object ???
    Retrying // Retrying a failed evacuate attempt
}

#[derive(Debug, Clone)]
struct EvacuateObject {
    id: String,
    object: MantaObject,
    status: EvacuateObjectStatus,
}

impl EvacuateObject {
    fn new(object: MantaObject) -> Self {
        Self {
            id: object.object_id.to_owned(),
            object,
            status: EvacuateObjectStatus::Unprocessed
        }
    }
}

#[derive(Clone, Debug)]
pub struct EvacuateJob {
    dest_shark_list: Vec<MantaObjectShark>,
    objects: Arc<Vec<EvacuateObject>>,
    assignments: Arc<Vec<Assignment>>,
    from_shark: MantaObjectShark,
    min_avail_mb: Option<u64>,
    max_tasks_per_assignment: Option<u32>,
}

#[derive(Clone, Debug)]
enum AssignmentState {
    Init,
    Assigned,
    Rejected,
    Complete,
}

#[derive(Debug, Clone)]
pub struct Assignment {
    id: String,
    dest_shark: MantaObjectShark,
    tasks: Vec<Task>,
    state: AssignmentState,
}

#[derive(Debug, Clone)]
pub struct Task {
    object_id: String, // or Uuid
    owner: String,     // or Uuid
    md5sum: String,
    source: MantaObjectShark, // or String MantaObjectShark::manta_storage_id
}

impl Default for Job {
    fn default() -> Self {
        Self {
            action: JobAction::default(),
            state: JobState::default(),
            id: Uuid::new_v4(),
            config: Config::default(),
        }
    }
}
impl Job {
    pub fn new(action: JobAction) -> Self {
        Job {
            action,
            ..Default::default()
        }
    }

    pub fn run(self) -> Result<(), Error> {
        match &self.action {
            JobAction::Evacuate(_) => run_evacuate_job(self),
            _ => Ok(()),
        }
    }
}

impl Default for JobAction {
    fn default() -> Self {
        JobAction::None
    }
}

impl Default for JobState {
    fn default() -> Self {
        JobState::Init
    }
}

impl EvacuateJob {
    pub fn new(from_shark: String) -> Self {
        Self {
            min_avail_mb: Some(1000),
            max_tasks_per_assignment: Some(10000),
            dest_shark_list: vec![],
            objects: vec![],
            assignments: vec![],
            from_shark: MantaObjectShark {
                manta_storage_id: from_shark,
                ..Default::default()
            },
        }
    }

    /// If an Assignment in the state of Assigned is found for the provided
    /// shark, then that shark is busy.
    fn shark_busy(&self, shark: &StorageNode) -> bool {
        let found = self.assignments.iter().find(|a| {
            if a.state == AssignmentState::Assigned {
                a.dest_shark == shark.manta_storage_id
            }
            false
        });
        found.is_some()
    }
}

impl PostActionAssignment for EvacuateJob {
    fn post_assignment(&mut self, mut assignment: Assignment)
    -> Result<(), Error>
    {

        // TODO: Send assignment to agent
        // TODO: put assignment into persistent store?
        assignment.state = AssignmentState::Assigned;
        self.assignments.push(assignment);
        Ok(())
    }
}

trait PostActionAssignment {
    fn post_assignment(&mut self, assign: Assignment) -> Result<(), Error>;
    // possible additions
    // check_assignments(&mut self)
    // get_assignment_for_shark(&mut self, &String)
}


// TODO: can I bring this into impl EvacuateJob
fn run_evacuate_job(job: Job) -> Result<(), Error> {
    dbg!(&job);
    let domain = &job.config.domain_name;
    let from_shark= match &job.action {
        JobAction::Evacuate(action) => {
            &action.from_shark.manta_storage_id
        }
        _ => {
            return Err(InternalError::new(
                Some(InternalErrorCode::InvalidJobAction),
                "Evacuate received invalid Job action",
            )
            .into());
        }
    };

    // TODO: Could combine these into a let (min, max) = ...
    let min_shard: u32 = job.config.shards
        .iter()
        .fold(0, |res, elem| {
            let shard_num = util::shard_host2num(&elem.host);

            if res < shard_num {
                return res;
            }

            shard_num
        });

    let max_shard: u32 = job.config.shards
        .iter()
        .fold(0, |res, elem| {
            let shard_num = util::shard_host2num(&elem.host);

            if res > shard_num {
                return res;
            }

            shard_num
        });


    println!("Starting Evacuate Job: {}", &job.id);

    // Steps:
    // 1. lock evacuating server to readonly

    // 2. run rust-sharkspotter to get list of objects
    //   - What data to retain?
    //   - Does this need to be done in series or parallel?
    let (tx, rx) = crossbeam::bounded(5);

    // TODO:
    // pass the job config here or gather data about the DC to pass to
    // run_sharkspotter()
    let sharkspotter_handle =
        start_sharkspotter(tx, domain, &from_shark, min_shard, max_shard);

    let assignment_handle = match start_assignment_thread(rx, job) {
        Ok(handle) => handle,
        Err(e) => return Err(e.into()),
    };

    sharkspotter_handle
        .join()
        .unwrap()
        .expect("Error joining sharkspotter thread");
    assignment_handle
        .join()
        .unwrap()
        .expect("Error joining assignment thread");

    Ok(())
}


/// Start the sharkspotter thread and feed the objects into the assignment
/// thread.  If the assignment thread (the rx side of the channel) exits
/// prematurely the sender.send() method will return a SenderError and that
/// needs to be handled properly.
fn start_sharkspotter(
    sender: crossbeam::Sender<MantaObject>,
    domain: &String,
    shark: &String,
    min_shard: u32,
    max_shard: u32,
) -> thread::JoinHandle<Result<(), Error>> {
    let config = sharkspotter::config::Config {
        domain: String::from(domain.as_str()),
        min_shard,
        max_shard,
        shark: String::from(shark.as_str()),
        ..Default::default()
    };

    let handle = thread::spawn(move || {
        let mut count = 0;
        sharkspotter::run(&config, move |obj, _shard| {
            // testing
            count += 1;
            if count > 1000 {
                return Err(std::io::Error::new(
                    ErrorKind::Other,
                    "Just stop already",
                ));
            }

            // TODO:
            // - add shard number
            // - convert error message "Result<(), SendError<MantaObject>>"
            sender.send(obj).map_err(Error::from).map_err(|e| {
                std::io::Error::new(ErrorKind::Other, e.description())
            })
        })
        .map_err(Error::from)
    });

    handle
}

/// Assignment Generation:
/// 1. Get snapshot from picker
/// 2. Check storage nodes that have availableMb > Some TBD threshold
/// 3. Generate assignment such that sum of all object sizes < Some rather
/// large threshold (order of GB) AND < half of available MB, whichever comes
/// first.
/// 4. Send assignment to storage node.
/// 5. Get next storage node with availableMb > Some TBD threshold and goto #3
///
/// Restrictions:
/// * Only 1 outstanding assignment per storage node (could change this in
/// the future, or make it tunable)
/// * If all storage ndoes with availableMb > Some TBD threshold have an
/// outstanding assignment, sleep/wait for an assignment to complete.
/// * When an assignment completes force(?) and update to picker, and goto #2
fn start_assignment_thread(
    obj_receiver: crossbeam::Receiver<MantaObject>,
    job: Job,
) -> Result<thread::JoinHandle<Result<(), Error>>, Error>
{
    let mut picker = mod_picker::Picker::new();

    picker.start()?;


    let handle = thread::spawn(move || {
        let mut job_action = match job.action {
            JobAction::Evacuate(action) => action,
            _ => return Err(InternalError::new(
                Some(InternalErrorCode::InvalidJobAction),
                "Only Evacuate jobs are supported").into()),
        };

        let from_shark_datacenter = job_action.from_shark.datacenter.to_owned();

        let algo = mod_picker::DefaultPickerAlgorithm{
            min_avail_mb: job_action.min_avail_mb,
            blacklist: vec![from_shark_datacenter]
        };


        // This will only go through one iteration of each shark (one
        // assignment per shark), which is obviously not acceptable.  We need
        // to decide how we are going to handle updating the data we get from
        // picker with our view of how much data we sent to each shark.
        let mut valid_sharks = match picker.choose(
            &mod_picker::PickerAlgorithm::Default(algo)
        ) {
            Some(s) => s,
            None => return Ok(())
        };

        let mut shark_index = 0;
        'assignment: loop {

            // TODO: allow for premature cancellation

            // If we've gone through all the sharks and given each an
            // assignment we
            if shark_index > valid_sharks.len() {
                // update shark_index = 0
                // sleep? or check for updates from assignments
                // get new picker snapshot (force?)

            }


            // Find the next shark which has enough space available.
            // TODO: Consider moving this in to picker::choose() and have it
            // take a Vec of sharks, and choose a single shark based on the
            // algorithm.
            let cur_shark: &mut StorageNode = &mut valid_sharks[shark_index];

            // Only use half of the available space per shark per assignment
            cur_shark.available_mb = cur_shark.available_mb / 2;

            if job_action.shark_busy(&cur_shark) {
                continue;
            }

            shark_index += 1;

            // TODO: we should be able to use the first shark as the picker
            // should keep them sorted by available_mb but that is probably
            // not a safe assumption in the long term.
            let dest_shark = MantaObjectShark{
                manta_storage_id: cur_shark.manta_storage_id.clone(),
                datacenter: cur_shark.datacenter.clone(),
            };

            let mut assignment = Assignment {
                id: String::from(""),
                dest_shark,
                tasks: vec![],
                state: AssignmentState::Init,
            };


            let mut mobj: EvacuateObject;
            // Build the per shark assignment
            'task: while {
                let mut cont = true;

                // If we have exceeded the per shark number of tasks then
                // move on.
                if let Some(max_tasks) = job_action.max_tasks_per_assignment {
                    if assignment.tasks.len() > (max_tasks - 1) as usize {
                        cont = false;
                    } else {
                        cont = true;
                    }
                }
                cont

            } {

                mobj = match obj_receiver.recv() {
                    Ok(obj) => EvacuateObject::new(obj),
                    Err(_) => {
                        // Post the current assignment and break out of
                        // the assignment loop.
                        if assignment.tasks.len() > 0 {
                            job_action.post_assignment(assignment);
                        }
                        break 'assignment
                    },
                };

                if mobj.object.content_length > cur_shark.available_mb {
                    mobj.status = EvacuateObjectStatus::Skipped;
                    job_action.objects.push(mobj);
                    continue;
                }

                let obj = &mobj.object;
                let from_shark_host = &job_action.from_shark.manta_storage_id;

                // pick source shark
                let source = match obj.sharks.iter().find(|s| {
                    &s.manta_storage_id != from_shark_host
                }) {
                    Some(src) => src,
                    None => {
                        // TODO: Skipped reason
                        mobj.status = EvacuateObjectStatus::Skipped;
                        job_action.objects.push(mobj);
                        continue;
                    },
                };

                // Add the task to the assignment
                // This creates a task copying the relevant fields of the
                // object.  The list of objects in the job_action.objects Vec
                // is tied to these by object_id.  Perhaps we can use
                // references here?
                assignment.tasks.push(Task{
                    object_id: obj.object_id.to_owned(),
                    owner: obj.owner.to_owned(),
                    md5sum: obj.content_md5.to_owned(),
                    source: source.to_owned(),
                });

                cur_shark.available_mb -= obj.content_length;

                mobj.status = EvacuateObjectStatus::Processing;
                job_action.objects.push(mobj);
            }

            job_action.post_assignment(assignment);

        }

        picker.fini()?;
        Ok(())
    });

    Ok(handle)
}


